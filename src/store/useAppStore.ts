import { create } from 'zustand';

export type IdentityPath = 'scholar' | 'warrior' | 'focus' | 'discipline';
export type AppMode = 'anonymous' | 'ai';
export type Gender = 'male' | 'female' | 'other';
export type ThemeType = 'default' | 'scholar-blue' | 'warrior-red' | 'focus-black' | 'discipline-gold' | 'solar' | 'ghost' | 'legacy' | 'dream';
export type TaskType = 'lesson' | 'practice' | 'revision' | 'test' | 'recall' | 'workout' | 'cardio' | 'rest' | 'deepwork' | 'admin' | 'planning' | 'reflection' | 'habit';

export interface ModeConfig {
  subjects?: string[];
  hoursDaily?: number;
  examDate?: string;
  fitnessLevel?: 'beginner' | 'intermediate' | 'advanced';
  location?: 'home' | 'gym';
  daysPerWeek?: number;
  studentType?: 'student' | 'entrepreneur' | 'creator';
  hoursAvailable?: number;
  wakeTime?: string;
  focusLevel?: number;
}

export interface NotificationSettings {
  enableVibration: boolean;
  enableSound: boolean;
  notifyIfTasksLeft: boolean;
  reminderMinutes: number; // minutes before the scheduled time
}

export interface Protocol {
  id: string;
  name: string;
  category: IdentityPath;
  taskType: TaskType;
  xp: number;
  completed: boolean;
  streak: number;
  remind: boolean;
  createdAt: number;
  autoGenerated?: boolean;
  isDaily?: boolean;
  scheduledTime?: string; // HH:MM format (e.g., "09:30")
  notificationSettings?: NotificationSettings;
}

export interface UserProfile {
  name: string;
  age: number;
  gender: Gender;
}

export interface CustomSettings {
  xpMultiplier: number;
  difficultyLevel: 'easy' | 'normal' | 'hard';
  autoGenerateTasks: boolean;
  showMotivationalMessages: boolean;
  enableNotifications: boolean;
  bgDimLevel: number;
}

export interface UserState {
  onboarded: boolean;
  identity: IdentityPath | null;
  mode: AppMode | null;
  profile: UserProfile | null;
  phase: number;
  level: number;
  totalXp: number;
  xpToNextLevel: number;
  xpToNextPhase: number;
  protocols: Protocol[];
  weeklyData: number[];
  monthlyData: number[];
  yearlyData: number[];
  isPremium: boolean;
  premiumTrialEndDate: string | null;
  currentTheme: ThemeType;
  unlockedThemes: ThemeType[];
  modeConfig: ModeConfig;
  lastTaskGenerationDate?: string;
  dailyTasksGenerated?: boolean;
  completionRateLast3Days: number;
  missionIntent: 'normal' | 'high-energy' | 'low-energy' | 'recovery';
  dayTaskIndex: number;
  lastCompletedDate: string;
  identityStrength: number;
  failureReasons: { date: string; reason: string }[];
  weeklyXpGain: number[];
  streakProtectionUsedDates: string[];
  backgroundImage: string | null;
  customSettings: CustomSettings;
  consecutiveDays: number;
  premiumUnlockedByStreak: boolean;
  premiumUnlockedByLevel10: boolean;
  premiumUnlockedByLevel100: boolean;
}

interface AppStore extends UserState {
  setIdentity: (identity: IdentityPath) => void;
  setMode: (mode: AppMode) => void;
  setProfile: (profile: UserProfile) => void;
  setModeConfig: (config: ModeConfig) => void;
  setTheme: (theme: ThemeType) => void;
  unlockTheme: (theme: ThemeType) => void;
  addProtocol: (protocol: Omit<Protocol, 'id' | 'completed' | 'streak' | 'createdAt'>) => void;
  toggleProtocol: (id: string) => void;
  resetDay: () => void;
  upgrade: () => void;
  startPremiumTrial: () => void;
  addXp: (amount: number) => void;
  generateDailyTasks: () => void;
  setMissionIntent: (intent: 'normal' | 'high-energy' | 'low-energy' | 'recovery') => void;
  recordFailureReason: (reason: string) => void;
  updateIdentityStrength: () => void;
  useStreakProtection: () => boolean;
  setBackgroundImage: (image: string | null) => void;
  updateCustomSettings: (settings: Partial<CustomSettings>) => void;
  checkAndUnlockPremium: () => void;
  incrementConsecutiveDays: () => void;
}

const PHASE_XP = [0, 100, 300, 600, 1000, 1500];
const LEVEL_XP = 50;


const loadState = (): Partial<UserState> => {
  try {
    const saved = localStorage.getItem('heena');
    return saved ? JSON.parse(saved) : {};
  } catch {
    return {};
  }
};

const saveState = (state: UserState) => {
  localStorage.setItem('heena', JSON.stringify(state));
};

const defaults: UserState = {
  onboarded: false,
  identity: null,
  mode: null,
  profile: null,
  phase: 1,
  level: 1,
  totalXp: 0,
  xpToNextLevel: LEVEL_XP,
  xpToNextPhase: 100,
  protocols: [],
  weeklyData: [0, 0, 0, 0, 0, 0, 0],
  monthlyData: Array(31).fill(0),
  yearlyData: Array(12).fill(0),
  isPremium: false,
  premiumTrialEndDate: null,
  currentTheme: 'default',
  unlockedThemes: ['default'],
  modeConfig: {},
  dailyTasksGenerated: false,
  completionRateLast3Days: 0,
  missionIntent: 'normal',
  dayTaskIndex: 0,
  lastCompletedDate: new Date().toISOString().split('T')[0],
  identityStrength: 0,
  failureReasons: [],
  weeklyXpGain: [0, 0, 0, 0, 0, 0, 0],
  streakProtectionUsedDates: [],
  backgroundImage: null,
  customSettings: {
    xpMultiplier: 1.0,
    difficultyLevel: 'normal',
    autoGenerateTasks: true,
    showMotivationalMessages: true,
    enableNotifications: true,
    bgDimLevel: 0.5,
  },
  consecutiveDays: 0,
  premiumUnlockedByStreak: false,
  premiumUnlockedByLevel10: false,
  premiumUnlockedByLevel100: false,
};

export const useAppStore = create<AppStore>((set, get) => {
  const saved = loadState();
  const initial = { ...defaults, ...saved };

  return {
    ...initial,

    setIdentity: (identity) => {
      let theme: ThemeType = 'default';
      switch (identity) {
        case 'scholar': theme = 'scholar-blue'; break;
        case 'warrior': theme = 'warrior-red'; break;
        case 'focus': theme = 'focus-black'; break;
        case 'discipline': theme = 'discipline-gold'; break;
      }
      const next = { ...get(), identity, currentTheme: theme, unlockedThemes: ['default' as ThemeType, theme] };
      set(next);
      saveState(next);
    },

    setMode: (mode) => {
      const next = { ...get(), onboarded: true, mode };
      set(next);
      saveState(next);
    },

    setProfile: (profile) => {
      const next = { ...get(), profile };
      set(next);
      saveState(next);
    },

    setModeConfig: (config) => {
      const next = { ...get(), modeConfig: config, dailyTasksGenerated: false };
      set(next);
      saveState(next);
    },

    setTheme: (theme: ThemeType) => {
      const state = get();
      const next = { ...state, currentTheme: theme };
      set(next);
      saveState(next);
    },

    unlockTheme: (theme: ThemeType) => {
      const state = get();
      if (!state.unlockedThemes.includes(theme)) {
        const next = { ...state, unlockedThemes: [...state.unlockedThemes, theme] };
        set(next);
        saveState(next);
      }
    },

    addProtocol: (proto) => {
      const state = get();
      if (!state.isPremium && state.protocols.length >= 5) return;
      const newProto: Protocol = {
        ...proto,
        id: crypto.randomUUID(),
        completed: false,
        streak: 0,
        createdAt: Date.now(),
      };
      const next = { ...state, protocols: [...state.protocols, newProto] };
      set(next);
      saveState(next);
    },

    addXp: (amount) => {
      const state = get();
      let totalXp = state.totalXp + amount;
      let level = state.level;
      let xpToNextLevel = state.xpToNextLevel;
      let phase = state.phase;
      let xpToNextPhase = state.xpToNextPhase;
      const unlockedThemes = [...state.unlockedThemes];

      while (totalXp >= xpToNextLevel && level < 50) {
        totalXp -= xpToNextLevel;
        level++;
        xpToNextLevel = LEVEL_XP;

        if (level % 5 === 0 && state.identity) {
          const themeMap: { [key in IdentityPath]: ThemeType } = {
            scholar: 'scholar-blue',
            warrior: 'warrior-red',
            focus: 'focus-black',
            discipline: 'discipline-gold',
          };
          const theme = themeMap[state.identity];
          if (theme && !unlockedThemes.includes(theme)) {
            unlockedThemes.push(theme);
          }
        }
      }

      while (totalXp >= xpToNextPhase && phase < PHASE_XP.length) {
        phase++;
        xpToNextPhase = PHASE_XP[phase] || xpToNextPhase + 500;
      }

      const next = {
        ...state,
        totalXp,
        level,
        xpToNextLevel,
        phase,
        xpToNextPhase,
        unlockedThemes,
      };
      set(next);
      saveState(next);
      setTimeout(() => get().checkAndUnlockPremium(), 50);
    },

    toggleProtocol: (id) => {
      const state = get();
      let xpGain = 0;
      const protocols = state.protocols.map((p) => {
        if (p.id !== id) return p;
        if (!p.completed) {
          xpGain = p.xp;
          return { ...p, completed: true, streak: p.streak + 1 };
        }
        xpGain = -p.xp;
        return { ...p, completed: false, streak: Math.max(0, p.streak - 1) };
      });

      const weeklyData = [...state.weeklyData];
      const today = new Date().getDay();
      weeklyData[today] = protocols.filter((p) => p.completed).length;

      const monthlyData = [...state.monthlyData];
      const dayOfMonth = new Date().getDate() - 1;
      monthlyData[dayOfMonth] = protocols.filter((p) => p.completed).length;

      const yearlyData = [...state.yearlyData];
      const month = new Date().getMonth();
      const monthTotal = protocols
        .filter((p) => {
          const createdMonth = new Date(p.createdAt).getMonth();
          return p.completed && createdMonth === month;
        }).length;
      yearlyData[month] = monthTotal;

      const weeklyXpGain = [...state.weeklyXpGain];
      weeklyXpGain[today] += Math.max(0, xpGain);

      const last3Days = weeklyData.slice(-3);
      const totalTasksLast3 = last3Days.reduce((a, b) => a + b, 0) || 1;
      const completedTasksLast3 = protocols.filter((p) => {
        const created = new Date(p.createdAt).getDay();
        const today = new Date().getDay();
        return p.completed && (today - created <= 3 && today - created >= 0);
      }).length;
      const completionRateLast3Days = (completedTasksLast3 / Math.max(1, totalTasksLast3)) * 100;

      const lastCompletedDate = xpGain > 0 ? new Date().toISOString().split('T')[0] : state.lastCompletedDate;
      
      let consecutiveDays = state.consecutiveDays;
      if (xpGain > 0 && lastCompletedDate !== state.lastCompletedDate) {
        consecutiveDays += 1;
      } else if (xpGain < 0 && protocols.filter((p) => p.completed).length === 0) {
        consecutiveDays = 0;
      }

      get().addXp(xpGain);
      const next = { 
        ...get(), 
        protocols, 
        weeklyData,
        monthlyData,
        yearlyData,
        weeklyXpGain,
        completionRateLast3Days,
        lastCompletedDate,
        consecutiveDays
      };
      set(next);
      saveState(next);
    },

    generateDailyTasks: () => {
      const state = get();
      const today = new Date().toISOString().split('T')[0];

      if (state.lastTaskGenerationDate === today) return;

      const { identity, modeConfig, completionRateLast3Days, missionIntent } = state;
      if (!identity) return;

      let newTasks: Protocol[] = [];

      let difficultyMultiplier = 1;
      let taskCountMultiplier = 1;
      if (completionRateLast3Days > 80) {
        difficultyMultiplier = 1.1;
        taskCountMultiplier = 1.2;
      } else if (completionRateLast3Days < 50) {
        taskCountMultiplier = 0.8;
      }

      const missionAdjustments: { [key: string]: number } = {
        'normal': 1,
        'high-energy': 1.3,
        'low-energy': 0.7,
        'recovery': 0.5,
      };
      const missionMultiplier = missionAdjustments[missionIntent] || 1;
      const finalMultiplier = difficultyMultiplier * missionMultiplier;

      const dayTaskIndex = (state.dayTaskIndex + 1) % 3;

      if (identity === 'scholar' && modeConfig.subjects) {
        const subjects = modeConfig.subjects;
        const hoursDaily = modeConfig.hoursDaily || 3;
        const timePerSubject = Math.floor((hoursDaily * 60) / subjects.length);
        
        const examDate = modeConfig.examDate ? new Date(modeConfig.examDate) : null;
        const daysToExam = examDate ? Math.floor((examDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : 999;
        let revisionBoost = 1;
        if (daysToExam < 30 && daysToExam > 0) {
          revisionBoost = 1.3;
        }

        subjects.forEach((subject) => {
          if (dayTaskIndex === 0 || dayTaskIndex === 1) {
            newTasks.push({
              id: crypto.randomUUID(),
              name: `${subject} - New Lesson`,
              category: 'scholar',
              taskType: 'lesson',
              xp: Math.round(10 * finalMultiplier),
              completed: false,
              streak: 0,
              remind: true,
              createdAt: Date.now(),
              autoGenerated: true,
            });

            newTasks.push({
              id: crypto.randomUUID(),
              name: `${subject} - Practice Questions`,
              category: 'scholar',
              taskType: 'practice',
              xp: Math.round(15 * finalMultiplier),
              completed: false,
              streak: 0,
              remind: true,
              createdAt: Date.now(),
              autoGenerated: true,
            });
          } else {
            newTasks.push({
              id: crypto.randomUUID(),
              name: `${subject} - Spaced Repetition`,
              category: 'scholar',
              taskType: 'revision',
              xp: Math.round(12 * finalMultiplier * revisionBoost),
              completed: false,
              streak: 0,
              remind: true,
              createdAt: Date.now(),
              autoGenerated: true,
            });

            newTasks.push({
              id: crypto.randomUUID(),
              name: `${subject} - Weak Areas Review`,
              category: 'scholar',
              taskType: 'practice',
              xp: Math.round(18 * finalMultiplier * revisionBoost),
              completed: false,
              streak: 0,
              remind: true,
              createdAt: Date.now(),
              autoGenerated: true,
            });
          }
        });

        newTasks.push({
          id: crypto.randomUUID(),
          name: 'Active Recall & Spaced Repetition',
          category: 'scholar',
          taskType: 'recall',
          xp: Math.round(12 * finalMultiplier),
          completed: false,
          streak: 0,
          remind: true,
          createdAt: Date.now(),
          autoGenerated: true,
        });

        if (daysToExam >= 7 || daysToExam < 0) {
          const today = new Date().getDay();
          if (today === 5) {
            newTasks.push({
              id: crypto.randomUUID(),
              name: 'Weekly Mock Test',
              category: 'scholar',
              taskType: 'test',
              xp: Math.round(25 * finalMultiplier * revisionBoost),
              completed: false,
              streak: 0,
              remind: true,
              createdAt: Date.now(),
              autoGenerated: true,
            });
          }
        }
      } else if (identity === 'warrior' && modeConfig.fitnessLevel) {
        const level = modeConfig.fitnessLevel;
        const workouts = ['Push Day', 'Pull Day', 'Legs', 'Cardio'];

        workouts.forEach((workout) => {
          const xpMap = { beginner: 15, intermediate: 20, advanced: 25 };
          newTasks.push({
            id: crypto.randomUUID(),
            name: workout,
            category: 'warrior',
            taskType: workout.includes('Cardio') ? 'cardio' : 'workout',
            xp: Math.round(xpMap[level] * finalMultiplier),
            completed: false,
            streak: 0,
            remind: true,
            createdAt: Date.now(),
            autoGenerated: true,
          });
        });
      } else if (identity === 'focus' && modeConfig.hoursAvailable) {
        const tasks = [
          { name: '90-Minute Deep Work Block', type: 'deepwork', xp: 25 },
          { name: 'Admin & Email Review', type: 'admin', xp: 5 },
          { name: 'Planning & Reflection', type: 'planning', xp: 8 },
        ];

        tasks.forEach((task) => {
          newTasks.push({
            id: crypto.randomUUID(),
            name: task.name,
            category: 'focus',
            taskType: task.type as TaskType,
            xp: Math.round(task.xp * finalMultiplier),
            completed: false,
            streak: 0,
            remind: true,
            createdAt: Date.now(),
            autoGenerated: true,
          });
        });
      } else if (identity === 'discipline') {
        const tasks = [
          { name: `Wake up at ${modeConfig.wakeTime || '6:00 AM'}`, xp: 10 },
          { name: 'Drink 8 glasses of water', xp: 5 },
          { name: 'Read 10 pages', xp: 10 },
          { name: 'No social media before 9 AM', xp: 8 },
          { name: 'Night reflection & journaling', xp: 12 },
        ];

        tasks.forEach((task) => {
          newTasks.push({
            id: crypto.randomUUID(),
            name: task.name,
            category: 'discipline',
            taskType: 'habit',
            xp: Math.round(task.xp * finalMultiplier),
            completed: false,
            streak: 0,
            remind: true,
            createdAt: Date.now(),
            autoGenerated: true,
          });
        });
      }

      const protocols = [...state.protocols.filter((p) => !p.autoGenerated), ...newTasks];
      const next = {
        ...state,
        protocols,
        lastTaskGenerationDate: today,
        dailyTasksGenerated: true,
        dayTaskIndex,
      };
      set(next);
      saveState(next);
    },

    resetDay: () => {
      const state = get();
      const protocols = state.protocols.map((p) => ({ ...p, completed: false }));
      const next = { ...state, protocols, dailyTasksGenerated: false };
      set(next);
      saveState(next);
      // Regenerate daily tasks
      setTimeout(() => get().generateDailyTasks(), 100);
    },

    upgrade: () => {
      const state = get();
      const next = { ...state, isPremium: true, premiumTrialEndDate: null };
      set(next);
      saveState(next);
    },

    startPremiumTrial: () => {
      const state = get();
      const trialEndDate = new Date();
      trialEndDate.setDate(trialEndDate.getDate() + 60); // 2 months (60 days) from now
      const next = { ...state, isPremium: true, premiumTrialEndDate: trialEndDate.toISOString().split('T')[0] };
      set(next);
      saveState(next);
    },

    setMissionIntent: (intent) => {
      const state = get();
      const next = { ...state, missionIntent: intent };
      set(next);
      saveState(next);
    },

    recordFailureReason: (reason) => {
      const state = get();
      const today = new Date().toISOString().split('T')[0];
      const newFailureReason = { date: today, reason };
      const next = { 
        ...state, 
        failureReasons: [...state.failureReasons.slice(-6), newFailureReason] 
      };
      set(next);
      saveState(next);
    },

    updateIdentityStrength: () => {
      const state = get();
      const today = new Date().toISOString().split('T')[0];
      
      // Calculation: completion rate last 7 days × streak multiplier
      const last7Days = state.weeklyData;
      const totalTasks = last7Days.reduce((a, b) => a + b, 0) || 1;
      const completedCount = state.protocols.filter((p) => p.completed).length;
      const baseStrength = (completedCount / Math.max(1, totalTasks)) * 100;
      
      // Streak multiplier (0.8 to 1.2)
      const streakDays = state.protocols.reduce((max, p) => Math.max(max, p.streak), 0);
      const streakMultiplier = Math.min(1.2, 1 + (streakDays * 0.05));
      
      const identityStrength = Math.min(100, Math.round(baseStrength * streakMultiplier));
      
      const next = { ...state, identityStrength };
      set(next);
      saveState(next);
    },

    useStreakProtection: () => {
      const state = get();
      if (!state.isPremium) return false;

      const today = new Date().toISOString().split('T')[0];
      
      // Check if already used this week
      const thisWeekStart = new Date();
      thisWeekStart.setDate(thisWeekStart.getDate() - thisWeekStart.getDay());
      
      const usedThisWeek = state.streakProtectionUsedDates.filter((date) => {
        const d = new Date(date);
        return d >= thisWeekStart;
      }).length;

      if (usedThisWeek >= 1) return false;

      const next = { 
        ...state, 
        streakProtectionUsedDates: [...state.streakProtectionUsedDates, today] 
      };
      set(next);
      saveState(next);
      return true;
    },

    setBackgroundImage: (image) => {
      const state = get();
      const next = { ...state, backgroundImage: image };
      set(next);
      saveState(next);
    },

    updateCustomSettings: (settings) => {
      const state = get();
      const next = { 
        ...state, 
        customSettings: { ...state.customSettings, ...settings }
      };
      set(next);
      saveState(next);
    },

    incrementConsecutiveDays: () => {
      const state = get();
      const next = { ...state, consecutiveDays: state.consecutiveDays + 1 };
      set(next);
      saveState(next);
      get().checkAndUnlockPremium();
    },

    checkAndUnlockPremium: () => {
      const state = get();
      let updated = false;
      const updates: any = {};

      // 7-day streak → 7 days premium
      if (
        state.consecutiveDays >= 7 &&
        !state.premiumUnlockedByStreak &&
        !state.isPremium
      ) {
        const trialEndDate = new Date();
        trialEndDate.setDate(trialEndDate.getDate() + 7);
        updates.isPremium = true;
        updates.premiumTrialEndDate = trialEndDate.toISOString().split('T')[0];
        updates.premiumUnlockedByStreak = true;
        updated = true;
      }

      // Level 10 → 2 months premium
      if (
        state.level >= 10 &&
        !state.premiumUnlockedByLevel10 &&
        !state.isPremium
      ) {
        const trialEndDate = new Date();
        trialEndDate.setDate(trialEndDate.getDate() + 60);
        updates.isPremium = true;
        updates.premiumTrialEndDate = trialEndDate.toISOString().split('T')[0];
        updates.premiumUnlockedByLevel10 = true;
        updated = true;
      }

      // Level 100 → forever premium
      if (state.level >= 100 && !state.premiumUnlockedByLevel100) {
        updates.isPremium = true;
        updates.premiumTrialEndDate = null;
        updates.premiumUnlockedByLevel100 = true;
        updated = true;
      }

      if (updated) {
        const next = { ...state, ...updates };
        set(next);
        saveState(next);
      }
    },
  };
});
